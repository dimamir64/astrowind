---
import CallToAction from '~/components/widgets/CallToAction.astro';
import Content from '~/components/widgets/Content.astro';
import Features2 from '~/components/widgets/Features2.astro';
import Hero from '~/components/widgets/Hero.astro';
import Testimonials from '~/components/widgets/Testimonials.astro';
import Layout from '~/layouts/PageLayout.astro';
//import RangeSlider  from '~/components/RangeSlider.svelte';
const metadata = {
  title: 'Редактирование теплохода',
};
---

<Layout metadata={metadata}>
  <button
    id="btn1"
    type="button"
    class="text-white bg-gradient-to-br from-purple-600 to-blue-500 hover:bg-gradient-to-bl focus:ring-4 focus:outline-none focus:ring-blue-300
  dark:focus:ring-blue-800 font-medium rounded-lg text-sm px-2 py-1 text-center mr-1 mb-1"
    >Добавить каюту</button
  >
  <button
    type="button"
    class="text-white bg-gradient-to-r from-cyan-500 to-blue-500 hover:bg-gradient-to-bl focus:ring-4 focus:outline-none focus:ring-cyan-300
  dark:focus:ring-cyan-800 font-medium rounded-lg text-sm px-2 py-1 text-center mr-1 mb-1"
    >Добавить помещение</button
  >
  <button
    type="button"
    class="text-white bg-gradient-to-br from-green-400 to-blue-600 hover:bg-gradient-to-bl focus:ring-4 focus:outline-none focus:ring-green-200
  dark:focus:ring-green-800 font-medium rounded-lg text-sm px-2 py-1 text-center mr-1 mb-1"
    >Клонировать</button
  >
  <button
    id="button"
    type="button"
    class="text-white bg-gradient-to-r from-purple-500 to-pink-500 hover:bg-gradient-to-l focus:ring-4 focus:outline-none focus:ring-purple-200
  dark:focus:ring-purple-800 font-medium rounded-lg text-sm px-2 py-1 text-center mr-1 mb-1"
    >Модальное окно</button
  >
  <button
    id="zoom0"
    type="button"
    class="text-gray-900 bg-gradient-to-r from-teal-200 to-lime-200 hover:bg-gradient-to-l
  hover:from-teal-200 hover:to-lime-200 focus:ring-4 focus:outline-none focus:ring-lime-200 dark:focus:ring-teal-700
  font-medium rounded-lg text-sm px-2 py-1 text-center mr-1 mb-1"
  >
  ---0---
  </button>
  <button
    id="savejson"
    type="button"
    class="text-gray-900 bg-gradient-to-r from-red-200 via-red-300 to-yellow-200
  hover:bg-gradient-to-bl focus:ring-4 focus:outline-none focus:ring-red-100 dark:focus:ring-red-400 font-medium
  rounded-lg text-sm px-2 py-1 text-center mr-1 mb-1"
    >Сохранить</button>
  <!--<RangeSlider values={[50]} pips /> -->
  <!--    Main modal -->
  <div
    id="defaultModal"
    tabindex="-1"
    aria-hidden="false"
    class="fixed top-0 left-0 right-0 z-50 hidden w-full p-4 overflow-x-hidden overflow-y-auto md:inset-0
        h-[calc(100%-1rem)] max-h-full"
  >
    <div class="relative w-full max-w-2xl max-h-full">
      <!-- Modal content -->
      <div class="relative bg-white rounded-lg shadow dark:bg-gray-700">
        <!-- Modal header -->
        <div class="flex items-start justify-between p-4 border-b rounded-t dark:border-gray-600">
          <h3 class="text-ml font-semibold text-gray-900 dark:text-white">Описание каюты</h3>
          <button
            type="button"
            class="text-gray-400 bg-transparent hover:bg-gray-200 hover:text-gray-900 rounded-lg text-sm p-1.5 ml-auto inline-flex items-center
          dark:hover:bg-gray-600 dark:hover:text-white"
            data-modal-hide="defaultModal"
          >
            <svg
              aria-hidden="true"
              class="w-5 h-5"
              fill="currentColor"
              viewBox="0 0 20 20"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                fill-rule="evenodd"
                d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                clip-rule="evenodd"></path></svg
            >
            <span class="sr-only">Закрыть</span>
          </button>
        </div>
        <!-- Modal body -->
        <div class="p-6 space-y-6">
          <p class="text-base leading-relaxed text-gray-500 dark:text-gray-400">Краткое описание</p>
          <p class="text-base leading-relaxed text-gray-500 dark:text-gray-400">Подробное Описание</p>
        </div>
        <!-- Modal footer -->
        <div class="flex items-center p-6 space-x-2 border-t border-gray-200 rounded-b dark:border-gray-600">
          <button
            data-modal-hide="defaultModal"
            type="button"
            class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300
              font-medium rounded-lg text-sm px-5 py-2.5 text-center dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800"
            >Подтвердить</button
          >
          <button
            data-modal-hide="defaultModal"
            type="button"
            class="text-gray-500 bg-white hover:bg-gray-100 focus:ring-4 focus:outline-none focus:ring-blue-300
              rounded-lg border border-gray-200 text-sm font-medium px-5 py-2.5 hover:text-gray-900 focus:z-10 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-500
            dark:hover:text-white dark:hover:bg-gray-600 dark:focus:ring-gray-600"
            >Отменить</button
          >
        </div>
      </div>
    </div>
  </div>
  <!--
  <a href="#" class="block max-w-lg p-2 bg-white border border-gray-200 rounded-lg shadow hover:bg-gray-100 dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-gray-700">
    <h5 class="mb-8 text-2xl font-bold tracking-tight text-gray-900 dark:text-white">Noteworthy technology acquisitions 2021</h5>
    <p class="font-normal text-gray-700 dark:text-gray-400">Here are the biggest enterprise technology acquisitions of 2021 so far, in reverse chronological order.</p>
  </a>
-->
  <div style="width=80%" id="stage-parent">
    <div
      id="container"
      class="appearance-none
    py-2
    px-4
    bg-slate-100 text-white font-semibold
    rounded-lg shadow-md
    hover:bg-gray-200 focus:outline-none focus:ring-2
    focus:ring-purple-400 focus:ring-opacity-75"
    >
    </div>
  </div>
</Layout>
<style>
  .zoom-container {
    position: absolute;
    top: 0;
    left: 0;
    padding: 2px;
  }
</style>

<script>
  import Konva from 'konva';
  import kauta from '../../data/49.json' assert { type: 'json' };
  import cl from '../../data/class-49.json' assert { type: 'json' };
  //import img from '~/assets/image/schema49.jpg';

  //import { Modal } from 'flowbite';
  // select the two elements that we'll work with
  const $buttonElement: HTMLElement | null = document.querySelector('#button');
  //const $modalElement: HTMLElement | null = document.querySelector('#defaultModal');
  // create a new modal component
  //  const modal = new Modal($modalElement);
  //console.log(modal);
  // toggle the visibility of the modal when clicking on the button
  if ($buttonElement) {
    //$buttonElement.addEventListener('click', () => modal.toggle());
  }
  var viewportwidth;
  var viewportheight;
  // the more standards compliant browsers (mozilla/netscape/opera/IE7) use window.innerWidth and window.innerHeight
  if (typeof window.innerWidth != 'undefined') {
    (viewportwidth = window.innerWidth), (viewportheight = window.innerHeight);
  }
  // IE6 in standards compliant mode (i.e. with a valid doctype as the first line in the document)
  else if (
    typeof document.documentElement != 'undefined' &&
    typeof document.documentElement.clientWidth != 'undefined' &&
    document.documentElement.clientWidth != 0
  ) {
    (viewportwidth = document.documentElement.clientWidth), (viewportheight = document.documentElement.clientHeight);
  }
  // older versions of IE
  else {
    (viewportwidth = document.getElementsByTagName('body')[0].clientWidth),
      (viewportheight = document.getElementsByTagName('body')[0].clientHeight);
  }
  //window.innerWidth
  var width = viewportwidth / 1.499 - 50;
  var height = width / 1.29 + 130;
  var scale = 1;
  var sceneWidth = (window.innerWidth / 1.499) * 1.4 - 50;
  var sceneHeight = (width / 1.29) * 1.0 + 130;
  var newPos = { x: 0, y: 0 };

  var stage = new Konva.Stage({
    container: 'container',
    width: width,
    height: height,
    stroke: 'black',
    strokeWidth: 2,
  });

  function fitStageIntoParentContainer() {
    var container = document.querySelector('#stage-parent');
    // now we need to fit stage into parent container
    var containerWidth = container.offsetWidth;
    // but we also make the full scene visible
    // so we need to scale all objects on canvas
    scale = containerWidth / sceneWidth;
    stage.width(sceneWidth * scale);
    stage.height(sceneHeight * scale);
    stage.scale({ x: scale, y: scale });
  }
  fitStageIntoParentContainer();
  // adapt the stage on any window resize
  window.addEventListener('resize', fitStageIntoParentContainer);

  console.log('w=', viewportwidth, 'h=', viewportheight, 'scale=', scale);

  var layer = new Konva.Layer();
  var layer0 = new Konva.Layer({ listening: false });
  var layer1 = new Konva.Layer();
  var group = new Konva.Group({
    x: 720,
    y: 40,
    rotation: 0,
    draggable: true,
  });
  stage.add(layer0);
  stage.add(layer1);
  var cls = [];
  var i = 0;
  cl.forEach(function (ee, key) {
    cls[ee.id] = { ...cl[i] };
    i++;
  });
  console.log('cls', cls);
  const scw = 1.499;
  const sch = 1.145;

  kauta.forEach(function (ee, key) {
    //	console.log(key, e);
    var k = new Konva.Rect({
      id: ee.id,
      id_class: ee.id_class,
      is_brigada: ee.is_brigada,
      num_kauta: ee.number,
      only_office: ee.only_office,
      timecreate: ee.timecreate,
      rate: ee.rate,
      place: ee.place,
      active: ee.active,
      x: parseInt(ee.x) * (width / 800),
      y: parseInt(ee.y) * ((height * sch * 0.99) / 800),
      width: parseInt(ee.width) * (width / 800),
      height: parseInt(ee.height) * ((height * sch) / 800),
      opacity: 0.5,
      draggable: true,
      strokeScaleEnabled: false,
      stroke: 'black',
      strokeWidth: 2,
      fill: ee.is_brigada == '0' ? '#aeb' : '#ebb',
      name: 'rect',
      sel: '0',
    });
    layer.add(k);
  });

  var imageObj = new Image();
  imageObj.onload = function () {
    var sh = new Konva.Image({
      x: 0,
      y: 0,
      image: imageObj,
      width: width,
      height: height,
      opacity: 1.0,
      draggable: false,
      name: 'rect1',
    });
    // add the shape to the layer
    layer0.add(sh);
    sh.moveToBottom();
  };
  imageObj.src = '/assets/images/schema49.jpg';
  //imageObj.src = 'src/assets/images/schema491.jpg';

  /*
  var rect1 = new Konva.Rect({
    x: 60,
    y: 60,
    width: 100,
    height: 90,
    fill: 'red',
    name: 'rect',
    draggable: true,
  });
  layer.add(rect1);

  var rect2 = new Konva.Rect({
    x: 250,
    y: 100,
    width: 150,
    height: 90,
    fill: 'green',
    name: 'rect',
    draggable: true,
  });
  layer.add(rect2);
*/
  var tr = new Konva.Transformer();
  layer.add(tr);
  tr.nodes();

  var selectionRectangle = new Konva.Rect({
    fill: 'rgba(0,0,255,0.5)',
    visible: false,
  });
  layer.add(selectionRectangle);
  stage.add(layer);

  var x1, y1, x2, y2;
  stage.on('mousedown touchstart', (e) => {
    // do nothing if we mousedown on any shape
    if (e.target !== stage) {
      return;
    }
    e.evt.preventDefault();
    x1 = stage.getPointerPosition().x / scale;
    y1 = stage.getPointerPosition().y / scale;
    x2 = stage.getPointerPosition().x / scale;
    y2 = stage.getPointerPosition().y / scale;

    selectionRectangle.visible(true);
    selectionRectangle.width(0);
    selectionRectangle.height(0);
  });

  stage.on('mousemove touchmove', (e) => {
    // do nothing if we didn't start selection
    if (!selectionRectangle.visible()) {
      return;
    }
    e.evt.preventDefault();
    x2 = stage.getPointerPosition().x / scale;
    y2 = stage.getPointerPosition().y / scale;

    selectionRectangle.setAttrs({
      x: Math.min(x1, x2) - newPos.x / scale,
      y: Math.min(y1, y2) - newPos.y / scale,
      width: Math.abs(x2 - x1),
      height: Math.abs(y2 - y1),
    });
  });

  var selected;
  stage.on('mouseup touchend', (e) => {
    // do nothing if we didn't start selection
    if (!selectionRectangle.visible()) {
      return;
    }
    e.evt.preventDefault();
    // update visibility in timeout, so we can check it in click event
    setTimeout(() => {
      selectionRectangle.visible(false);
    });

    var shapes = stage.find('.rect');
    var box = selectionRectangle.getClientRect();
    selected = shapes.filter((shape) => Konva.Util.haveIntersection(box, shape.getClientRect()));

    //selected.forEach(function (shape) { shape.setAttrs({ fill:"#abc",sel:"1"})  });
    tr.nodes(selected);
  });

  // clicks should select/deselect shapes
  stage.on('click tap', function (e) {
    // if we are selecting with rect, do nothing
    if (selectionRectangle.visible()) {
      return;
    }

    // if click on empty area - remove all selections
    if (e.target === stage) {
      //selected.forEach(function (shape) { shape.setAttrs({ fill:"#aeb",sel:"0"})  });
      tr.nodes([]);
      return;
    }

    // do nothing if clicked NOT on our rectangles
    if (!e.target.hasName('rect')) {
      return;
    }

    // do we pressed shift or ctrl?
    const metaPressed = e.evt.shiftKey || e.evt.ctrlKey || e.evt.metaKey;
    const isSelected = tr.nodes().indexOf(e.target) >= 0;

    if (!metaPressed && !isSelected) {
      // if no key pressed and the node is not selected
      // select just one
      tr.nodes([e.target]);
    } else if (metaPressed && isSelected) {
      // if we pressed keys and node was selected
      // we need to remove it from selection:
      const nodes = tr.nodes().slice(); // use slice to have new copy of array
      // remove node from array
      nodes.splice(nodes.indexOf(e.target), 1);
      tr.nodes(nodes);
    } else if (metaPressed && !isSelected) {
      // add the node into selection
      const nodes = tr.nodes().concat([e.target]);
      tr.nodes(nodes);
    }
  });

  var text = new Konva.Text({
    x: width,
    y: 5,
    width: 300,
    fontSize: 18,
    fontFamily: 'Calibri',
    stroke: '#777',
    strokeWidth: 1,
    text: '',
  });
  layer.add(text);
  var t0 = new Konva.Text({
    x: 0,
    y: 0,
  });

  layer.add(text);

  const ch = window.screen.availHeight;
  const cw = viewportwidth;

  function updateText(sh) {
    var ic = parseInt(sh.getAttr('id_class'));
    var ib = parseInt(sh.getAttr('is_brigada')) == 1 ? 'Бригадная каюта' : '';
    if (ic > 0) {
      var lines = [
        'Палуба: ' + sh.getAttr('deck'),
        'Каюта: ' + sh.getAttr('num_kauta'),
        'Класс: ' + cls[ic].name,
        'Осн мест: ' + cls[ic].num,
        'Доп мест: ' + cls[ic].num_add,
        'Описание: ' + cls[ic].description,
        'Блокировка: ' + ib,
        'id: ' + sh.id(),
        'id_class: ' + sh.getAttr('id_class'),
        'is_brigada: ' + sh.getAttr('is_brigada'),
        'rate: ' + sh.getAttr('rate'),
        'timecreate: ' + sh.getAttr('timecreate'),
        'only_office: ' + sh.getAttr('only_office'),
        'place: ' + sh.getAttr('place'),
        'active: ' + sh.getAttr('active'),
        'x: ' + sh.x(),
        'y: ' + sh.y(),
        'rotation: ' + sh.rotation(),
        'width: ' + sh.width(),
        'height: ' + sh.height(),
        'scaleX: ' + sh.scaleX(),
        'scaleY: ' + sh.scaleY(),
      ];
    } else {
      var lines = ['Каюта не настроена'];
    }
    text.text(lines.join('\n'));
    const t0p = t0.absolutePosition();
    const shp = sh.absolutePosition();
    const sp = stage.absolutePosition();
    if (shp.y + text.height() > ch) {
      text.y(ch - text.height() - (shp.y - sh.y()));
    } else {
      text.y(sh.y());
    }
    //const textp = text.absolutePosition();
    //console.log('text', text," sp", sp," shp", shp," ch", ch," sh.y()", sh.y()," text.height()", text.height()," textp", textp, " t0p", t0p);
    // text.drow();
  }

  var selel;
  tr.on('transform', function (evt) {
    var box = evt.target;
    //        box.fill('#E5FF80');
    //        box.draw();
    // updateText(box);
  });
  tr.on('transformend', function (evt) {
    selel = evt.target;
    //        box.fill('#E5FF80');
    //        box.draw();
    updateText(selel);
  });
  tr.on('transformon', function (evt) {
    var box = evt.target;
    //        box.fill('#E5FF80');
    //        box.draw();
    // updateText(box);
  });

  stage.on('click', function (evt) {
    if (evt.target.getAttr('name') == 'rect') {
      selel = evt.target;
      //        box.fill('#E5FF80');
      //        box.draw();
      updateText(selel);
    }
  });
  stage.on('dragmove', function (evt) {
    /*    if (evt.target.getAttr("name")=="rect"){
    selel = evt.target;
    selel.fill('#E5FF80');
    selel.draw();
    //updateText(box);
  }*/
  });

  layer.on('mouseover', function (evt) {
    if (evt.target.getAttr('name') == 'rect') {
      if (selel) {
        if (selel.getAttr('id') > 0) {
          selel.fill(selel.getAttr('is_brigada') == '0' ? '#aeb' : '#ebb');
        } else {
          selel.fill('#eba');
        }
      }
      selel = evt.target;
      selel.fill('#E5FF80');
      selel.draw();
      updateText(selel);
    }
  });
  layer.on('mouseout', function (evt) {
    if (evt.target.getAttr('name') == 'rect') {
      selel = evt.target;
      if (selel.getAttr('id') > 0) {
        selel.fill(selel.getAttr('is_brigada') == '0' ? '#aeb' : '#ebb');
      } else {
        selel.fill('#eba');
      }
      selel.draw();
      //  text.text('');
    }
  });

  document.getElementById('btn1').addEventListener('click', addbox);

  let cnt = 0;
  function addbox() {
    var rect = new Konva.Rect({
      x: Math.random() * 30,
      y: Math.random() * 30,
      fill: '#eba',
      width: 20 + Math.random() * 50,
      height: 20 + Math.random() * 50,
      /*      stroke: '#777',
      strokeWidth: 1,
      shadowColor: 'black',
      shadowBlur: 3,
      shadowOffsetX: 3,
      shadowOffsetY: 3,
      shadowOpacity: 0.1,
      cornerRadius: 3,*/
      id: '0',
      id_class: 0,
      is_brigada: 0,
      num_kauta: 0,
      only_office: 9,
      timecreate: 0,
      rate: 0,
      place: 0,
      active: 0,
      stroke: 'black',
      strokeWidth: 2,
      opacity: 0.5,
      draggable: true,
      strokeScaleEnabled: false,
      name: 'rect',
    });
    cnt++;
    //tx[0].text('tooltip Указатель вниз\nПроверка нескольких строк. длинный текст\n'+"Добавлено "+cnt+" объектов"+'\n\n Пропуск 3 строки\n\n');
    layer.add(rect);
    //layer.forceUpdate();
  }
  /*
  function limitAttributes(stage, newAttrs) {
    const box = stage.findOne('Image').getClientRect();
    const minX = -box.width + stage.width() / 2;
    const maxX = stage.width() / 2;

    const x = Math.max(minX, Math.min(newAttrs.x, maxX));

    const minY = -box.height + stage.height() / 2;
    const maxY = stage.height() / 2;

    const y = Math.max(minY, Math.min(newAttrs.y, maxY));

    const scale = Math.max(0.05, newAttrs.scale);

    return { x, y, scale };
}

  function zoomStage(stage, scaleBy) {
    const oldScale = stage.scaleX();

    const pos = {
      x: stage.width() / 2,
      y: stage.height() / 2,
    };
    const mousePointTo = {
      x: pos.x / oldScale - stage.x() / oldScale,
      y: pos.y / oldScale - stage.y() / oldScale,
    };

    const newScale = Math.max(0.05, oldScale * scaleBy);

    const newPos = {
      x: -(mousePointTo.x - pos.x / newScale) * newScale,
      y: -(mousePointTo.y - pos.y / newScale) * newScale,
    };

    const newAttrs = limitAttributes(stage, { ...newPos, scale: newScale });

    stage.to({
      x: newAttrs.x,
      y: newAttrs.y,
      scaleX: newAttrs.scale,
      scaleY: newAttrs.scale,
      duration: 0.1,
    });
  }  
  document.getElementById('incr').addEventListener('click', zoomStage(stage, 1.2));
  document.getElementById('decr').addEventListener('click', zoomStage(stage, 0.8));
  */

  document.getElementById('zoom0').addEventListener('click', zoom0);
  document.getElementById('savejson').addEventListener('click', savejson);

  function savejson() {
    var json = stage.toJSON();

    console.log(json);
  }
  function zoom0() {
    //  stage.scale({ x: scale, y: scale });
    fitStageIntoParentContainer();
    newPos = { x: 0, y: 0 };
    stage.position(newPos);
  }

  var scaleBy = 1.1;
  stage.on('wheel', (e) => {
    // stop default scrolling
    e.evt.preventDefault();

    var oldScale = stage.scaleX();
    var pointer = stage.getPointerPosition();

    var mousePointTo = {
      x: (pointer.x - stage.x()) / oldScale,
      y: (pointer.y - stage.y()) / oldScale,
    };

    // how to scale? Zoom in? Or zoom out?
    let direction = e.evt.deltaY > 0 ? 1 : -1;

    // when we zoom on trackpad, e.evt.ctrlKey is true
    // in that case lets revert direction
    if (e.evt.ctrlKey) {
      direction = -direction;
    }

    var newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;
    scale = newScale;
    stage.scale({ x: newScale, y: newScale });

    newPos = {
      x: pointer.x - mousePointTo.x * newScale,
      y: pointer.y - mousePointTo.y * newScale,
    };
    stage.position(newPos);
  });

  /* var container = stage.container();

  container.tabIndex = 1;
  container.focus();
  const DELTA = 1;
  container.addEventListener('keydown', function (e) {
    if (e.keyCode === 37) {
      selel.x(selel.x() - DELTA);
    } else if (e.keyCode === 38) {
      selel.y(selel.y() - DELTA);
    } else if (e.keyCode === 39) {
      selel.x(selel.x() + DELTA);
    } else if (e.keyCode === 40) {
      selel.y(selel.y() + DELTA);
    } else {
      return;
    }
    e.preventDefault();
  });
 
function getDistance(p1, p2) {
        return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
      }

      function getCenter(p1, p2) {
        return {
          x: (p1.x + p2.x) / 2,
          y: (p1.y + p2.y) / 2,
        };
      }
      var lastCenter = null;
      var lastDist = 0;

      stage.on('touchmove', function (e) {
        e.evt.preventDefault();
        var touch1 = e.evt.touches[0];
        var touch2 = e.evt.touches[1];

        if (touch1 && touch2) {
          // if the stage was under Konva's drag&drop
          // we need to stop it, and implement our own pan logic with two pointers
          if (stage.isDragging()) {
            stage.stopDrag();
          }

          var p1 = {
            x: touch1.clientX,
            y: touch1.clientY,
          };
          var p2 = {
            x: touch2.clientX,
            y: touch2.clientY,
          };

          if (!lastCenter) {
            lastCenter = getCenter(p1, p2);
            return;
          }
          var newCenter = getCenter(p1, p2);

          var dist = getDistance(p1, p2);

          if (!lastDist) {
            lastDist = dist;
          }

          // local coordinates of center point
          var pointTo = {
            x: (newCenter.x - stage.x()) / stage.scaleX(),
            y: (newCenter.y - stage.y()) / stage.scaleX(),
          };

          var scale = stage.scaleX() * (dist / lastDist);

          stage.scaleX(scale);
          stage.scaleY(scale);

          // calculate new position of the stage
          var dx = newCenter.x - lastCenter.x;
          var dy = newCenter.y - lastCenter.y;

          var newPos = {
            x: newCenter.x - pointTo.x * scale + dx,
            y: newCenter.y - pointTo.y * scale + dy,
          };

          stage.position(newPos);

          lastDist = dist;
          lastCenter = newCenter;
        }
      });

      stage.on('touchend', function () {
        lastDist = 0;
        lastCenter = null;
      });
*/
  //      savejson
</script>
